<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D Room Project</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@latest/build/three.module.js",
            "three/examples/jsm/loaders/GLTFLoader": "https://unpkg.com/three@latest/examples/jsm/loaders/GLTFLoader.js",
            "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@latest/examples/jsm/controls/OrbitControls.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
        //追加
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // ==========================================
        // 1. シーン・レンダラー・カメラの基本設定
        // ==========================================
        const scene = new THREE.Scene();

        
        // =======
        // 1.5 背景色の代わりに、全天球画像を設定
        const textureLoader = new THREE.TextureLoader();
        // 画像のパスを指定
        const texture = textureLoader.load('./background.png'); 
        // 全天球としてマッピングする設定
        texture.mapping = THREE.EquirectangularReflectionMapping; 
        // 色空間の設定
        texture.colorSpace = THREE.SRGBColorSpace;
        scene.background = texture;
        //scene.background = new THREE.Color(0x000000); // 背景色（暗いグレー）
        // =======


        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // 明るさの補正（Blenderの色味に近づける設定）
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true; // レンダラーで影を許可
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(7, 7, 7); // カメラの初期位置

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 操作に滑らかな慣性をつける

        //上半分のみカメラが動くように設定
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        //遠くまでカメラが行き過ぎないように設定
        controls.maxDistance = 100;

        // ==========================================
        // 2. 照明設定
        // ==========================================
        
        // --- 環境光 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // --- 太陽光 (DirectionalLight) ---
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(0, 10, -8);
        sunLight.castShadow = true; 
        sunLight.shadow.camera.left = -10;
        sunLight.shadow.camera.right = 10;
        sunLight.shadow.camera.top = 10;
        sunLight.shadow.camera.bottom = -10;
        scene.add(sunLight);

        const helper_sun = new THREE.DirectionalLightHelper(sunLight, 5);
        scene.add(helper_sun);

        // --- 天井からの点光源 (pointLight) ---
        const pointLight = new THREE.PointLight(0xffffff, 1.5, 50, 1.2);
        pointLight.position.set(0, 2, 0);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 1024;
        pointLight.shadow.mapSize.height = 1024;
        pointLight.shadow.bias = -0.005;
        scene.add(pointLight);

        const helper = new THREE.PointLightHelper(pointLight);
        scene.add(helper);

        // --- ランプの明かり (Lamp) ---
        const Lamp = new THREE.PointLight(0xFFD580, 1, 100);
        Lamp.position.set(-1.53, 1.3, 1); 
        Lamp.castShadow = true; 
        Lamp.shadow.camera.left = -10;
        Lamp.shadow.camera.right = 10;
        Lamp.shadow.camera.top = 10;
        Lamp.shadow.camera.bottom = -10;
        scene.add(Lamp);    

        const helper_lamp = new THREE.PointLightHelper(Lamp);
        scene.add(helper_lamp);

        // ==========================================
        // 時間帯切り替え関数の定義
        // ==========================================
        function updateScene(time) {
            // 全てのライトを一旦オフに近い状態にする
            sunLight.intensity = 0;
            pointLight.intensity = 0;
            Lamp.intensity = 0;
            ambientLight.intensity = 0.1; 

            switch(time) {
                case 'morning':
                    console.log("朝のシーン");
                    sunLight.intensity = 0.8;
                    sunLight.color.setHex(0xFFF4E0);
                    sunLight.position.set(-10, 5, -8); 
                    ambientLight.intensity = 0.4;
                    break;

                case 'noon':
                    console.log("昼のシーン");
                    sunLight.intensity = 1.2;
                    sunLight.color.setHex(0xffffff); 
                    sunLight.position.set(0, 10, -10); 
                    ambientLight.intensity = 0.6;
                    break;

                case 'evening':
                    console.log("夕方のシーン");
                    sunLight.intensity = 1.0;
                    sunLight.color.setHex(0xFF8C00);
                    sunLight.position.set(10, 5, -5);
                    Lamp.intensity = 1.5;
                    ambientLight.intensity = 0.3;
                    break;

                case 'night':
                    console.log("夜のシーン");
                    pointLight.intensity = 1.8;
                    pointLight.distance = 50;
                    pointLight.decay = 1.0;
                    Lamp.intensity = 1.2;
                    ambientLight.intensity = 0.1; 
                    break;
            }

            // ヘルパーを最新の位置に更新
            helper_sun.update();
            helper.update();
            helper_lamp.update();
        }

        // --- キーボード入力のイベントリスナー ---
        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case '1': updateScene('morning'); break;
                case '2': updateScene('noon'); break;
                case '3': updateScene('evening'); break;
                case '4': updateScene('night'); break;
            }
        });

        // ==========================================
        // 2.5 地面の作成（丸みを帯びた地球）
        // ==========================================
        
        // 地球の半径
        const earthRadius = 1000; 

        // 球体のジオメトリ（半径, 横縦の分割数，　球の計算範囲etc）
        const earthGeometry = new THREE.SphereGeometry(
            earthRadius, 
            64, 
            64,
            0, 
            Math.PI * 2, 
            0, 
            Math.PI * 0.25
        );

        // 地面のマテリアル（色や質感）
        const earthMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x55aa55, // 緑色（草の色）
            roughness: 0.9,  
            metalness: 0.0   
        });

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);

        // 位置の調整（球の半径分だけ下げる。2cmほど追加で下げ、ぴったり重ならないようにする。）
        earth.position.y = -earthRadius - 0.02;

        // 影を受ける設定
        earth.receiveShadow = true;

        scene.add(earth);

        // ==========================================
        // 3. モデルの読み込み
        // ==========================================
        const loader = new GLTFLoader();

        // ★追加: Dracoローダーの設定
        const dracoLoader = new DRACOLoader();
        // デコーダー（解凍用ファイル）の場所を指定（Web上のCDNを指定）
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
        // GLTFLoaderにDracoローダーを紐付ける
        loader.setDRACOLoader(dracoLoader);

        // 読み込みたいファイルのパスを指定
        const modelPath = './furnitureCenter.glb'; 
        
        loader.load(
            modelPath,
            (gltf) => {
                const room = gltf.scene;
                
                // 必要であればここで位置や向きを調整
                room.position.set(0, 0, 0);
                // 影の設定 
                room.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                scene.add(room);
                console.log("モデルの読み込みが完了しました:", modelPath);
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% 読み込み中');
            },
            (error) => {
                console.error("読み込みエラーが発生しました:", error);
            }
        );

        const modelPath2 = './furnitureNearWall.glb'; 
        
        loader.load(
            modelPath2,
            (gltf) => {
                const room = gltf.scene;
                
                // 必要であればここで位置や向きを調整
                room.position.set(0, 0, 0);
                // 影の設定 
                room.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                scene.add(room);
                console.log("モデルの読み込みが完了しました:", modelPath);
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% 読み込み中');
            },
            (error) => {
                console.error("読み込みエラーが発生しました:", error);
            }
        );

        const modelPath3 = './room.glb'; 
        
        loader.load(
            modelPath3,
            (gltf) => {
                const room = gltf.scene;
                
                // 必要であればここで位置や向きを調整
                room.position.set(0, 0, 0); 
                // 影の設定
                room.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                scene.add(room);
                console.log("モデルの読み込みが完了しました:", modelPath2);
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% 読み込み中');
            },
            (error) => {
                console.error("読み込みエラーが発生しました:", error);
            }
        );

        
        // ==========================================
        // 4. アニメーションとリサイズ対応
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>